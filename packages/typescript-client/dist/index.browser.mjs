var gs=Object.defineProperty,Es=Object.defineProperties;var Ss=Object.getOwnPropertyDescriptors;var Ie=Object.getOwnPropertySymbols;var Dt=Object.prototype.hasOwnProperty,Ht=Object.prototype.propertyIsEnumerable;var It=r=>{throw TypeError(r)};var Lt=(r,e,t)=>e in r?gs(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,S=(r,e)=>{for(var t in e||(e={}))Dt.call(e,t)&&Lt(r,t,e[t]);if(Ie)for(var t of Ie(e))Ht.call(e,t)&&Lt(r,t,e[t]);return r},re=(r,e)=>Es(r,Ss(e));var Nt=(r,e)=>{var t={};for(var s in r)Dt.call(r,s)&&e.indexOf(s)<0&&(t[s]=r[s]);if(r!=null&&Ie)for(var s of Ie(r))e.indexOf(s)<0&&Ht.call(r,s)&&(t[s]=r[s]);return t};var it=(r,e,t)=>e.has(r)||It("Cannot "+t);var n=(r,e,t)=>(it(r,e,"read from private field"),t?t.call(r):e.get(r)),d=(r,e,t)=>e.has(r)?It("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(r):e.set(r,t),c=(r,e,t,s)=>(it(r,e,"write to private field"),s?s.call(r,t):e.set(r,t),t),p=(r,e,t)=>(it(r,e,"access private method"),t);var Ne=(r,e,t,s)=>({set _(a){c(r,e,a,t)},get _(){return n(r,e,s)}});var x=class r extends Error{constructor(t,s,a,o,i,h){super(h||`HTTP Error ${t} at ${i}: ${s!=null?s:JSON.stringify(a)}`);this.url=i;this.name="FetchError",this.status=t,this.text=s,this.json=a,this.headers=o}static async fromResponse(t,s){let a=t.status,o=Object.fromEntries([...t.headers.entries()]),i,h,l=t.headers.get("content-type");return t.bodyUsed||(l&&l.includes("application/json")?h=await t.json():i=await t.text()),new r(a,i,h,o,s)}},O=class extends Error{constructor(){super("Fetch with backoff aborted"),this.name="FetchBackoffAbortError"}};var Fe=class extends Error{constructor(){super("Invalid shape options: missing required url parameter"),this.name="MissingShapeUrlError"}},Be=class extends Error{constructor(){super("Invalid signal option. It must be an instance of AbortSignal."),this.name="InvalidSignalError"}},qe=class extends Error{constructor(){super("shapeHandle is required if this isn't an initial fetch (i.e. offset > -1)"),this.name="MissingShapeHandleError"}},je=class extends Error{constructor(e){super(`Cannot use reserved Electric parameter names in custom params: ${e.join(", ")}`),this.name="ReservedParamError"}},Ve=class extends Error{constructor(e){super(`Column "${e!=null?e:"unknown"}" does not allow NULL values`),this.name="ParserNullValueError"}};var ne=class extends Error{constructor(e,t){let s=`The response for the shape request to ${e} didn't include the following required headers:
`;t.forEach(a=>{s+=`- ${a}
`}),s+=`
This is often due to a proxy not setting CORS correctly so that all Electric headers can be read by the client.`,s+=`
For more information visit the troubleshooting guide: /docs/guides/troubleshooting/missing-headers`,super(s)}};var Ye=r=>Number(r),ys=r=>r==="true"||r==="t",Rs=r=>BigInt(r),Ft=r=>JSON.parse(r),bs=r=>r,As={int2:Ye,int4:Ye,int8:Rs,bool:ys,float4:Ye,float8:Ye,json:Ft,jsonb:Ft};function xs(r,e){let t=0,s=null,a="",o=!1,i=0,h;function l(u,g,R){let A=u.slice(g,R);return A=A==="NULL"?null:A,e?e(A):A}function m(u){let g=[];for(;t<u.length;t++){if(s=u[t],o)s==="\\"?a+=u[++t]:s==='"'?(g.push(e?e(a):a),a="",o=u[t+1]==='"',i=t+2):a+=s;else if(s==='"')o=!0;else if(s==="{")i=++t,g.push(m(u));else if(s==="}"){o=!1,i<t&&g.push(l(u,i,t)),i=t+1;break}else s===","&&h!=="}"&&h!=='"'&&(g.push(l(u,i,t)),i=t+1);h=s}return i<t&&g.push(g.push(l(u,i,t+1))),g}return m(r)[0]}var We=class{constructor(e,t){this.parser=S(S({},As),e),this.transformer=t}parse(e,t){return JSON.parse(e,(s,a)=>(s==="value"||s==="old_value")&&typeof a=="object"&&a!==null?this.transformMessageValue(a,t):a)}parseSnapshotData(e,t){return e.map(s=>{let a=s;return a.value&&typeof a.value=="object"&&a.value!==null&&(a.value=this.transformMessageValue(a.value,t)),a.old_value&&typeof a.old_value=="object"&&a.old_value!==null&&(a.old_value=this.transformMessageValue(a.old_value,t)),a})}transformMessageValue(e,t){let s=e;return Object.keys(s).forEach(a=>{s[a]=this.parseRow(a,s[a],t)}),this.transformer?this.transformer(s):s}parseRow(e,t,s){var g;let a=s[e];if(!a)return t;let u=a,{type:o,dims:i}=u,h=Nt(u,["type","dims"]),l=(g=this.parser[o])!=null?g:bs,m=Bt(l,a,e);return i&&i>0?Bt((A,E)=>xs(A,m),a,e)(t):m(t,h)}};function Bt(r,e,t){var a;let s=!((a=e.not_null)!=null&&a);return o=>{if(o===null){if(!s)throw new Ve(t!=null?t:"unknown");return null}return r(o,e)}}function qt(r){return`"${r.replace(/"/g,'""')}"`}function ot(r){var h,l,m,u;let e=(l=(h=r.match(/^_+/))==null?void 0:h[0])!=null?l:"",t=r.slice(e.length),s=(u=(m=t.match(/_+$/))==null?void 0:m[0])!=null?u:"",i=(s?t.slice(0,t.length-s.length):t).toLowerCase().replace(/_+([a-z])/g,(g,R)=>R.toUpperCase());return e+i+s}function jt(r){return r.replace(/([a-z])([A-Z])/g,"$1_$2").replace(/([A-Z]+)([A-Z][a-z])/g,"$1_$2").toLowerCase()}function Vt(r){let e={};for(let[t,s]of Object.entries(r))e[s]=t;return{decode:t=>{var s;return(s=r[t])!=null?s:t},encode:t=>{var s;return(s=e[t])!=null?s:t}}}function Ke(r,e){if(!r||!e)return r!=null?r:"";r=r.replace(/"([^"]+)"/g,(h,l)=>`"${e(l)}"`);let t=new Set(["SELECT","FROM","WHERE","AND","OR","NOT","IN","IS","NULL","NULLS","FIRST","LAST","TRUE","FALSE","LIKE","ILIKE","BETWEEN","ASC","DESC","LIMIT","OFFSET","ORDER","BY","GROUP","HAVING","DISTINCT","AS","ON","JOIN","LEFT","RIGHT","INNER","OUTER","CROSS","CASE","WHEN","THEN","ELSE","END","CAST","LOWER","UPPER","COALESCE","NULLIF"]),s=[],a=0;for(;a<r.length;){let h=r[a];if(h==="'"||h==='"'){let l=a,m=h;for(a++;a<r.length;)if(r[a]===m)if(r[a+1]===m)a+=2;else{a++;break}else a++;s.push({start:l,end:a})}else a++}let o=h=>s.some(l=>h>=l.start&&h<l.end),i=new RegExp("(?<![a-zA-Z0-9_])([a-zA-Z_][a-zA-Z0-9_]*)(?![a-zA-Z0-9_])","g");return r.replace(i,(h,l,m)=>o(m)||t.has(h.toUpperCase())||h.startsWith("$")?h:e(h))}function _s(r){if(r){let e={};for(let t of Object.keys(r))e[t]=ot(t);return Vt(e)}return{decode:e=>ot(e),encode:e=>jt(e)}}function ae(r){return"key"in r}function Qe(r){return!ae(r)}function ct(r){return Qe(r)&&r.headers.control==="up-to-date"}function Yt(r){if(r.headers.control!="up-to-date")return;let e=r.headers.global_last_seen_lsn;return e?`${e}_0`:void 0}function ht(r,e){let t=BigInt(r),s=BigInt(e.xmin),a=BigInt(e.xmax),o=e.xip_list.map(BigInt);return t<s||t<a&&!o.includes(t)}var Wt="electric-cursor",ye="electric-handle",$e="electric-offset",lt="electric-schema",Kt="electric-up-to-date",ut="columns",Ge="cursor",Re="expired_handle",ie="handle",L="live",oe="offset",Qt="table",$t="where",Gt="replica",zt="params",Jt="experimental_live_sse",dt="live_sse",ft="force-disconnect-and-refresh",pt="pause-stream",mt="log",be="subset__where",Ae="subset__limit",xe="subset__offset",_e="subset__order_by",Pe="subset__params",gt=[L,dt,ie,oe,Ge,Re,mt,be,Ae,xe,_e,Pe];var Ps=[429],Je={initialDelay:100,maxDelay:6e4,multiplier:1.3,maxRetries:1/0};function Ts(r){if(!r)return 0;let e=Number(r);if(Number.isFinite(e)&&e>0)return e*1e3;let t=Date.parse(r);if(!isNaN(t)){let s=t-Date.now();return Math.max(0,Math.min(s,36e5))}return 0}function Zt(r,e=Je){let{initialDelay:t,maxDelay:s,multiplier:a,debug:o=!1,onFailedAttempt:i,maxRetries:h=1/0}=e;return async(...l)=>{var A;let m=l[0],u=l[1],g=t,R=0;for(;;)try{let E=await r(...l);if(E.ok)return E;throw await x.fromResponse(E,m.toString())}catch(E){if(i==null||i(),(A=u==null?void 0:u.signal)!=null&&A.aborted)throw new O;if(E instanceof x&&!Ps.includes(E.status)&&E.status>=400&&E.status<500)throw E;{if(R++,R>h)throw o&&console.log(`Max retries reached (${R}/${h}), giving up`),E;let _=E instanceof x&&E.headers?Ts(E.headers["retry-after"]):0,J=Math.random()*g,He=Math.min(J,s),Ot=Math.max(_,He);if(o){let at=_>0?"server+client":"client";console.log(`Retry attempt #${R} after ${Ot}ms (${at}, serverMin=${_}ms, clientBackoff=${He}ms)`)}await new Promise(at=>setTimeout(at,Ot)),g=Math.min(g*a,s)}}}}var ws=[201,204,205];function Xt(r){return async(...e)=>{var a,o;let t=e[0],s=await r(...e);try{if(s.status<200||ws.includes(s.status))return s;let i=await s.text();return new Response(i,s)}catch(i){throw(o=(a=e[1])==null?void 0:a.signal)!=null&&o.aborted?new O:new x(s.status,void 0,void 0,Object.fromEntries([...s.headers.entries()]),t.toString(),i instanceof Error?i.message:typeof i=="string"?i:"failed to read body")}}}var Ms={maxChunksToPrefetch:2};function es(r,e=Ms){let{maxChunksToPrefetch:t}=e,s;return async(...o)=>{let i=o[0].toString(),h=s==null?void 0:s.consume(...o);if(h)return h;s==null||s.abort(),s=void 0;let l=await r(...o),m=St(i,l);return m&&(s=new Et({fetchClient:r,maxPrefetchedRequests:t,url:m,requestInit:o[1]})),l}}var vs=["electric-offset","electric-handle"],Cs=["electric-cursor"],ks=["electric-schema"];function ts(r){return async(...e)=>{let t=await r(...e);if(t.ok){let s=t.headers,a=[],o=u=>a.push(...u.filter(g=>!s.has(g))),h=e[0].toString(),l=new URL(h);if([be,Pe,Ae,xe,_e].some(u=>l.searchParams.has(u)))return t;if(o(vs),l.searchParams.get(L)==="true"&&o(Cs),(!l.searchParams.has(L)||l.searchParams.get(L)==="false")&&o(ks),a.length>0)throw new ne(h,a)}return t}}var Te,we,M,Z,D,ce,ze,Et=class{constructor(e){d(this,ce);d(this,Te);d(this,we);d(this,M,new Map);d(this,Z);d(this,D);var t;c(this,Te,(t=e.fetchClient)!=null?t:(...s)=>fetch(...s)),c(this,we,e.maxPrefetchedRequests),c(this,Z,e.url.toString()),c(this,D,n(this,Z)),p(this,ce,ze).call(this,e.url,e.requestInit)}abort(){n(this,M).forEach(([e,t])=>t.abort()),n(this,M).clear()}consume(...e){let t=e[0].toString(),s=n(this,M).get(t);if(!s||t!==n(this,Z))return;let[a,o]=s;if(o.signal.aborted){n(this,M).delete(t);return}return n(this,M).delete(t),a.then(i=>{let h=St(t,i);c(this,Z,h),n(this,D)&&!n(this,M).has(n(this,D))&&p(this,ce,ze).call(this,n(this,D),e[1])}).catch(()=>{}),a}};Te=new WeakMap,we=new WeakMap,M=new WeakMap,Z=new WeakMap,D=new WeakMap,ce=new WeakSet,ze=function(...e){var a,o;let t=e[0].toString();if(n(this,M).size>=n(this,we))return;let s=new AbortController;try{let{signal:i,cleanup:h}=Us(s,(a=e[1])==null?void 0:a.signal),l=n(this,Te).call(this,t,re(S({},(o=e[1])!=null?o:{}),{signal:i}));n(this,M).set(t,[l,s]),l.then(m=>{if(!m.ok||s.signal.aborted)return;let u=St(t,m);if(!u||u===t){c(this,D,void 0);return}return c(this,D,u),p(this,ce,ze).call(this,u,e[1])}).catch(()=>{}).finally(h)}catch(i){}};function St(r,e){let t=e.headers.get(ye),s=e.headers.get($e),a=e.headers.has(Kt);if(!t||!s||a)return;let o=new URL(r);if(o.searchParams.has(L))return;let i=o.searchParams.get(Re);if(i&&t===i){console.warn(`[Electric] Received stale cached response with expired shape handle. This should not happen and indicates a proxy/CDN caching misconfiguration. The response contained handle "${t}" which was previously marked as expired. Check that your proxy includes all query parameters (especially 'handle' and 'offset') in its cache key. Skipping prefetch to prevent infinite 409 loop.`);return}return o.searchParams.set(ie,t),o.searchParams.set(oe,s),o.searchParams.sort(),o.toString()}function Us(r,e){let t=Os;if(e)if(e.aborted)r.abort();else{let s=()=>r.abort();e.addEventListener("abort",s,{once:!0,signal:r.signal}),t=()=>e.removeEventListener("abort",s)}return{signal:r.signal,cleanup:t}}function Os(){}import{fetchEventSource as Ls}from"@microsoft/fetch-event-source";var yt=class{constructor(){this.data={};this.max=250;this.storageKey="electric_expired_shapes";this.load()}getExpiredHandle(e){let t=this.data[e];return t?(t.lastUsed=Date.now(),this.save(),t.expiredHandle):null}markExpired(e,t){this.data[e]={expiredHandle:t,lastUsed:Date.now()};let s=Object.keys(this.data);if(s.length>this.max){let a=s.reduce((o,i)=>this.data[i].lastUsed<this.data[o].lastUsed?i:o);delete this.data[a]}this.save()}save(){if(typeof localStorage!="undefined")try{localStorage.setItem(this.storageKey,JSON.stringify(this.data))}catch(e){}}load(){if(typeof localStorage!="undefined")try{let e=localStorage.getItem(this.storageKey);e&&(this.data=JSON.parse(e))}catch(e){this.data={}}}clear(){this.data={},this.save()}},Ze=new yt;var Rt=class{constructor(){this.data={};this.storageKey="electric_up_to_date_tracker";this.cacheTTL=6e4;this.maxEntries=250;this.writeThrottleMs=6e4;this.lastWriteTime=0;this.load(),this.cleanup()}recordUpToDate(e,t){this.data[e]={timestamp:Date.now(),cursor:t};let s=Object.keys(this.data);if(s.length>this.maxEntries){let a=s.reduce((o,i)=>this.data[i].timestamp<this.data[o].timestamp?i:o);delete this.data[a]}this.scheduleSave()}scheduleSave(){let e=Date.now(),t=e-this.lastWriteTime;if(t>=this.writeThrottleMs)this.lastWriteTime=e,this.save();else if(!this.pendingSaveTimer){let s=this.writeThrottleMs-t;this.pendingSaveTimer=setTimeout(()=>{this.lastWriteTime=Date.now(),this.pendingSaveTimer=void 0,this.save()},s)}}shouldEnterReplayMode(e){let t=this.data[e];return!t||Date.now()-t.timestamp>=this.cacheTTL?null:t.cursor}cleanup(){let e=Date.now(),t=Object.keys(this.data),s=!1;for(let a of t)e-this.data[a].timestamp>this.cacheTTL&&(delete this.data[a],s=!0);s&&this.save()}save(){if(typeof localStorage!="undefined")try{localStorage.setItem(this.storageKey,JSON.stringify(this.data))}catch(e){}}load(){if(typeof localStorage!="undefined")try{let e=localStorage.getItem(this.storageKey);e&&(this.data=JSON.parse(e))}catch(e){this.data={}}}clear(){this.data={},this.pendingSaveTimer&&(clearTimeout(this.pendingSaveTimer),this.pendingSaveTimer=void 0),this.save()}},bt=new Rt;var Xe=class{constructor(){this.activeSnapshots=new Map;this.xmaxSnapshots=new Map;this.snapshotsByDatabaseLsn=new Map}addSnapshot(e,t){var o,i,h,l;this.activeSnapshots.set(e.snapshot_mark,{xmin:BigInt(e.xmin),xmax:BigInt(e.xmax),xip_list:e.xip_list.map(BigInt),keys:t});let s=(i=(o=this.xmaxSnapshots.get(BigInt(e.xmax)))==null?void 0:o.add(e.snapshot_mark))!=null?i:new Set([e.snapshot_mark]);this.xmaxSnapshots.set(BigInt(e.xmax),s);let a=(l=(h=this.snapshotsByDatabaseLsn.get(BigInt(e.database_lsn)))==null?void 0:h.add(e.snapshot_mark))!=null?l:new Set([e.snapshot_mark]);this.snapshotsByDatabaseLsn.set(BigInt(e.database_lsn),a)}removeSnapshot(e){this.activeSnapshots.delete(e)}shouldRejectMessage(e){let t=e.headers.txids||[];if(t.length===0)return!1;let s=Math.max(...t);for(let[a,o]of this.xmaxSnapshots.entries())if(s>=a)for(let i of o)this.removeSnapshot(i);return[...this.activeSnapshots.values()].some(a=>a.keys.has(e.key)&&ht(s,a))}lastSeenUpdate(e){for(let[t,s]of this.snapshotsByDatabaseLsn.entries())if(t<=e)for(let a of s)this.removeSnapshot(a)}};var Ds=new Set([Ge,ie,L,oe]);async function Ct(r){return typeof r=="function"?r():r}async function Hs(r){let e=Object.entries(r),t=await Promise.all(e.map(async([s,a])=>{if(a===void 0)return[s,void 0];let o=await Ct(a);return[s,Array.isArray(o)?o.join(","):o]}));return Object.fromEntries(t.filter(([s,a])=>a!==void 0))}async function Is(r){if(!r)return{};let e=Object.entries(r),t=await Promise.all(e.map(async([s,a])=>[s,await Ct(a)]));return Object.fromEntries(t)}function Me(r){let e=new URL(r.origin+r.pathname);for(let[t,s]of r.searchParams)gt.includes(t)||e.searchParams.set(t,s);return e.searchParams.sort(),e.toString()}var he,le,ue,X,q,U,b,H,I,j,w,ee,C,P,V,N,de,k,te,F,fe,Y,pe,ke,W,B,me,se,K,Ue,Oe,Q,tt,ge,st,rt,Le,f,xt,ve,Ce,_t,rs,Pt,et,ns,as,is,Tt,wt,os,cs,Mt,vt,hs,ls,At=class{constructor(e){d(this,f);d(this,he,null);d(this,le);d(this,ue);d(this,X);d(this,q,new Map);d(this,U,!1);d(this,b,"active");d(this,H);d(this,I);d(this,j);d(this,w,!1);d(this,ee,!0);d(this,C,!1);d(this,P);d(this,V);d(this,N);d(this,de);d(this,k);d(this,te,!1);d(this,F);d(this,fe);d(this,Y);d(this,pe,Promise.resolve([]));d(this,ke,new Xe);d(this,W,0);d(this,B);d(this,me);d(this,se);d(this,K);d(this,Ue);d(this,Oe,1e3);d(this,Q,0);d(this,tt,3);d(this,ge,!1);d(this,st,100);d(this,rt,5e3);d(this,Le);var i,h,l,m;this.options=S({subscribe:!0},e),Ns(this.options),c(this,H,(i=this.options.offset)!=null?i:"-1"),c(this,I,""),c(this,P,this.options.handle);let t;if(e.columnMapper){let u=g=>{let R={};for(let[A,E]of Object.entries(g)){let _=e.columnMapper.decode(A);R[_]=E}return R};t=e.transformer?g=>e.transformer(u(g)):u}else t=e.transformer;c(this,X,new We(e.parser,t)),c(this,de,this.options.onError),c(this,V,(h=this.options.log)!=null?h:"full");let s=(l=e.fetchClient)!=null?l:(...u)=>fetch(...u),a=re(S({},(m=e.backoffOptions)!=null?m:Je),{onFailedAttempt:()=>{var u,g;c(this,C,!1),(g=(u=e.backoffOptions)==null?void 0:u.onFailedAttempt)==null||g.call(u)}}),o=Zt(s,a);c(this,ue,ts(es(o))),c(this,le,Xt(n(this,ue))),p(this,f,hs).call(this)}get shapeHandle(){return n(this,P)}get error(){return n(this,he)}get isUpToDate(){return n(this,w)}get lastOffset(){return n(this,H)}get mode(){return n(this,V)}subscribe(e,t=()=>{}){let s=Math.random();return n(this,q).set(s,[e,t]),n(this,U)||p(this,f,ve).call(this),()=>{n(this,q).delete(s)}}unsubscribeAll(){var e;n(this,q).clear(),(e=n(this,Le))==null||e.call(this)}lastSyncedAt(){return n(this,j)}lastSynced(){return n(this,j)===void 0?1/0:Date.now()-n(this,j)}isConnected(){return n(this,C)}isLoading(){return!n(this,w)}hasStarted(){return n(this,U)}isPaused(){return n(this,b)==="paused"}async forceDisconnectAndRefresh(){var e,t;c(this,te,!0),n(this,w)&&!((e=n(this,k))!=null&&e.signal.aborted)&&((t=n(this,k))==null||t.abort(ft)),await p(this,f,os).call(this),c(this,te,!1)}async requestSnapshot(e){if(n(this,V)==="full")throw new Error(`Snapshot requests are not supported in ${n(this,V)} mode, as the consumer is guaranteed to observe all data`);n(this,U)||await p(this,f,ve).call(this),await p(this,f,cs).call(this),Ne(this,W)._++;try{n(this,W)===1&&p(this,f,Tt).call(this);let{metadata:t,data:s}=await this.fetchSnapshot(e),a=s.concat([{headers:S({control:"snapshot-end"},t)},{headers:S({control:"subset-end"},e)}]);return n(this,ke).addSnapshot(t,new Set(s.map(o=>o.key))),p(this,f,et).call(this,a,!1),{metadata:t,data:s}}finally{Ne(this,W)._--,n(this,W)===0&&p(this,f,wt).call(this)}}async fetchSnapshot(e){var m;let{fetchUrl:t,requestHeaders:s}=await p(this,f,_t).call(this,this.options.url,!0,e),a=await n(this,le).call(this,t.toString(),{headers:s});if(!a.ok)throw new x(a.status,void 0,void 0,Object.fromEntries([...a.headers.entries()]),t.toString());let o=(m=n(this,N))!=null?m:ss(a.headers,{required:!0,url:t.toString()}),{metadata:i,data:h}=await a.json(),l=n(this,X).parseSnapshotData(h,o);return{metadata:i,data:l}}};he=new WeakMap,le=new WeakMap,ue=new WeakMap,X=new WeakMap,q=new WeakMap,U=new WeakMap,b=new WeakMap,H=new WeakMap,I=new WeakMap,j=new WeakMap,w=new WeakMap,ee=new WeakMap,C=new WeakMap,P=new WeakMap,V=new WeakMap,N=new WeakMap,de=new WeakMap,k=new WeakMap,te=new WeakMap,F=new WeakMap,fe=new WeakMap,Y=new WeakMap,pe=new WeakMap,ke=new WeakMap,W=new WeakMap,B=new WeakMap,me=new WeakMap,se=new WeakMap,K=new WeakMap,Ue=new WeakMap,Oe=new WeakMap,Q=new WeakMap,tt=new WeakMap,ge=new WeakMap,st=new WeakMap,rt=new WeakMap,Le=new WeakMap,f=new WeakSet,xt=function(){return n(this,se)!==void 0},ve=async function(){var e,t,s,a,o;c(this,U,!0);try{await p(this,f,Ce).call(this)}catch(i){if(c(this,he,i),n(this,de)){let h=await n(this,de).call(this,i);if(h&&typeof h=="object"){h.params&&(this.options.params=S(S({},(e=this.options.params)!=null?e:{}),h.params)),h.headers&&(this.options.headers=S(S({},(t=this.options.headers)!=null?t:{}),h.headers)),c(this,he,null),c(this,U,!1),await p(this,f,ve).call(this);return}i instanceof Error&&p(this,f,vt).call(this,i),c(this,C,!1),(s=n(this,Y))==null||s.call(this);return}throw i instanceof Error&&p(this,f,vt).call(this,i),c(this,C,!1),(a=n(this,Y))==null||a.call(this),i}c(this,C,!1),(o=n(this,Y))==null||o.call(this)},Ce=async function(){var l,m;if(n(this,b)==="pause-requested"){c(this,b,"paused");return}if(!this.options.subscribe&&((l=this.options.signal)!=null&&l.aborted||n(this,w)))return;let e=n(this,b)==="paused";c(this,b,"active");let{url:t,signal:s}=this.options,{fetchUrl:a,requestHeaders:o}=await p(this,f,_t).call(this,t,e),i=await p(this,f,rs).call(this,s),h=n(this,k);try{await p(this,f,ns).call(this,{fetchUrl:a,requestAbortController:h,headers:o,resumingFromPause:e})}catch(u){if((u instanceof x||u instanceof O)&&h.signal.aborted&&h.signal.reason===ft)return p(this,f,Ce).call(this);if(u instanceof O){let g=n(this,b);h.signal.aborted&&h.signal.reason===pt&&g==="pause-requested"&&c(this,b,"paused");return}if(!(u instanceof x))throw u;if(u.status==409){if(n(this,P)){let R=Me(a);Ze.markExpired(R,n(this,P))}let g=u.headers[ye]||`${n(this,P)}-next`;return p(this,f,ls).call(this,g),await p(this,f,Mt).call(this,Array.isArray(u.json)?u.json:[u.json]),p(this,f,Ce).call(this)}else throw u}finally{i&&s&&s.removeEventListener("abort",i),c(this,k,void 0)}return(m=n(this,fe))==null||m.call(this),p(this,f,Ce).call(this)},_t=async function(e,t,s){var u,g,R,A;let[a,o]=await Promise.all([Is(this.options.headers),this.options.params?Hs(Fs(this.options.params)):void 0]);o&&us(o);let i=new URL(e);if(o){if(o.table&&v(i,Qt,o.table),o.where&&typeof o.where=="string"){let _=Ke(o.where,(u=this.options.columnMapper)==null?void 0:u.encode);v(i,$t,_)}if(o.columns){let _=await Ct((g=this.options.params)==null?void 0:g.columns);if(Array.isArray(_)){let J=_.map(String);this.options.columnMapper&&(J=J.map(this.options.columnMapper.encode));let He=J.map(qt).join(",");v(i,ut,He)}else v(i,ut,o.columns)}o.replica&&v(i,Gt,o.replica),o.params&&v(i,zt,o.params);let E=S({},o);delete E.table,delete E.where,delete E.columns,delete E.replica,delete E.params;for(let[_,J]of Object.entries(E))v(i,_,J)}if(s){if(s.where&&typeof s.where=="string"){let E=Ke(s.where,(R=this.options.columnMapper)==null?void 0:R.encode);v(i,be,E)}if(s.params&&i.searchParams.set(Pe,JSON.stringify(s.params)),s.limit&&v(i,Ae,s.limit),s.offset&&v(i,xe,s.offset),s.orderBy&&typeof s.orderBy=="string"){let E=Ke(s.orderBy,(A=this.options.columnMapper)==null?void 0:A.encode);v(i,_e,E)}}i.searchParams.set(oe,n(this,H)),i.searchParams.set(mt,n(this,V));let h=s!==void 0;n(this,w)&&!h&&(!n(this,te)&&!t&&i.searchParams.set(L,"true"),i.searchParams.set(Ge,n(this,I))),n(this,P)&&i.searchParams.set(ie,n(this,P));let l=Me(i),m=Ze.getExpiredHandle(l);return m&&i.searchParams.set(Re,m),i.searchParams.sort(),{fetchUrl:i,requestHeaders:a}},rs=async function(e){var t;if(c(this,k,new AbortController),e){let s=()=>{var a;(a=n(this,k))==null||a.abort(e.reason)};return e.addEventListener("abort",s,{once:!0}),e.aborted&&((t=n(this,k))==null||t.abort(e.reason)),s}},Pt=async function(e){var h;let{headers:t,status:s}=e,a=t.get(ye);if(a){let l=n(this,K)?Me(n(this,K)):null,m=l?Ze.getExpiredHandle(l):null;a!==m?c(this,P,a):console.warn(`[Electric] Received stale cached response with expired shape handle. This should not happen and indicates a proxy/CDN caching misconfiguration. The response contained handle "${a}" which was previously marked as expired. Check that your proxy includes all query parameters (especially 'handle' and 'offset') in its cache key. Ignoring the stale handle and continuing with handle "${n(this,P)}".`)}let o=t.get($e);o&&c(this,H,o);let i=t.get(Wt);i&&c(this,I,i),c(this,N,(h=n(this,N))!=null?h:ss(t)),s===204&&c(this,j,Date.now())},et=async function(e,t=!1){var s;if(e.length>0){c(this,ee,!0);let a=e[e.length-1];if(ct(a)){if(t){let i=Yt(a);i&&c(this,H,i)}if(c(this,j,Date.now()),c(this,w,!0),c(this,ee,!1),(s=n(this,me))==null||s.call(this),n(this,f,xt)&&!t&&n(this,I)===n(this,se))return;if(c(this,se,void 0),n(this,K)){let i=Me(n(this,K));bt.recordUpToDate(i,n(this,I))}}let o=e.filter(i=>ae(i)?!n(this,ke).shouldRejectMessage(i):!0);await p(this,f,Mt).call(this,o)}},ns=async function(e){var s;if(c(this,K,e.fetchUrl),!n(this,w)&&!n(this,f,xt)){let a=Me(e.fetchUrl),o=bt.shouldEnterReplayMode(a);o&&c(this,se,o)}let t=(s=this.options.liveSse)!=null?s:this.options.experimentalLiveSse;return n(this,w)&&t&&!n(this,te)&&!e.resumingFromPause&&!n(this,ge)?(e.fetchUrl.searchParams.set(Jt,"true"),e.fetchUrl.searchParams.set(dt,"true"),p(this,f,is).call(this,e)):p(this,f,as).call(this,e)},as=async function(e){let{fetchUrl:t,requestAbortController:s,headers:a}=e,o=await n(this,le).call(this,t.toString(),{signal:s.signal,headers:a});c(this,C,!0),await p(this,f,Pt).call(this,o);let i=n(this,N),l=await o.text()||"[]",m=n(this,X).parse(l,i);await p(this,f,et).call(this,m)},is=async function(e){let{fetchUrl:t,requestAbortController:s,headers:a}=e,o=n(this,ue);c(this,Ue,Date.now());let i=re(S({},a),{Accept:"text/event-stream"});try{let h=[];await Ls(t.toString(),{headers:i,fetch:o,onopen:async l=>{c(this,C,!0),await p(this,f,Pt).call(this,l)},onmessage:l=>{if(l.data){let m=n(this,N),u=n(this,X).parse(l.data,m);h.push(u),ct(u)&&(p(this,f,et).call(this,h,!0),h=[])}},onerror:l=>{throw l},signal:s.signal})}catch(h){throw s.signal.aborted?new O:h}finally{let h=Date.now()-n(this,Ue),l=s.signal.aborted;if(h<n(this,Oe)&&!l)if(Ne(this,Q)._++,n(this,Q)>=n(this,tt))c(this,ge,!0),console.warn("[Electric] SSE connections are closing immediately (possibly due to proxy buffering or misconfiguration). Falling back to long polling. Your proxy must support streaming SSE responses (not buffer the complete response). Configuration: Nginx add 'X-Accel-Buffering: no', Caddy add 'flush_interval -1' to reverse_proxy. Note: Do NOT disable caching entirely - Electric uses cache headers to enable request collapsing for efficiency.");else{let m=Math.min(n(this,rt),n(this,st)*Math.pow(2,n(this,Q))),u=Math.floor(Math.random()*m);await new Promise(g=>setTimeout(g,u))}else h>=n(this,Oe)&&c(this,Q,0)}},Tt=function(){var e;n(this,U)&&n(this,b)==="active"&&(c(this,b,"pause-requested"),(e=n(this,k))==null||e.abort(pt))},wt=function(){var e;if(n(this,U)&&(n(this,b)==="paused"||n(this,b)==="pause-requested")){if((e=this.options.signal)!=null&&e.aborted)return;n(this,b)==="pause-requested"&&c(this,b,"active"),p(this,f,ve).call(this)}},os=async function(){return n(this,F)?n(this,F):(c(this,F,new Promise((e,t)=>{c(this,fe,e),c(this,Y,t)})),n(this,F).finally(()=>{c(this,F,void 0),c(this,fe,void 0),c(this,Y,void 0)}),n(this,F))},cs=async function(){if(n(this,ee))return n(this,B)?n(this,B):(c(this,B,new Promise(e=>{c(this,me,e)})),n(this,B).finally(()=>{c(this,B,void 0),c(this,me,void 0)}),n(this,B))},Mt=async function(e){return c(this,pe,n(this,pe).then(()=>Promise.all(Array.from(n(this,q).values()).map(async([t,s])=>{try{await t(e)}catch(a){queueMicrotask(()=>{throw a})}})))),n(this,pe)},vt=function(e){n(this,q).forEach(([t,s])=>{s==null||s(e)})},hs=function(){if(typeof document=="object"&&typeof document.hidden=="boolean"&&typeof document.addEventListener=="function"){let e=()=>{document.hidden?p(this,f,Tt).call(this):p(this,f,wt).call(this)};document.addEventListener("visibilitychange",e),c(this,Le,()=>{document.removeEventListener("visibilitychange",e)})}},ls=function(e){c(this,H,"-1"),c(this,I,""),c(this,P,e),c(this,w,!1),c(this,ee,!0),c(this,C,!1),c(this,N,void 0),c(this,W,0),c(this,Q,0),c(this,ge,!1)},At.Replica={FULL:"full",DEFAULT:"default"};function ss(r,e){let t=r.get(lt);if(!t){if(e!=null&&e.required&&(e!=null&&e.url))throw new ne(e.url,[lt]);return{}}return JSON.parse(t)}function us(r){if(!r)return;let e=Object.keys(r).filter(t=>Ds.has(t));if(e.length>0)throw new je(e)}function Ns(r){if(!r.url)throw new Fe;if(r.signal&&!(r.signal instanceof AbortSignal))throw new Be;if(r.offset!==void 0&&r.offset!=="-1"&&r.offset!=="now"&&!r.handle)throw new qe;us(r.params)}function v(r,e,t){if(!(t===void 0||t==null))if(typeof t=="string")r.searchParams.set(e,t);else if(typeof t=="object")for(let[s,a]of Object.entries(t))r.searchParams.set(`${e}[${s}]`,a);else r.searchParams.set(e,t.toString())}function Fs(r){return Array.isArray(r.params)?re(S({},r),{params:Object.fromEntries(r.params.map((e,t)=>[t+1,e]))}):r}var T,$,G,De,Ee,Se,z,y,fs,ps,kt,nt,ms,Ut,ds=class{constructor(e){d(this,y);d(this,T,new Map);d(this,$,new Map);d(this,G,new Set);d(this,De,new Set);d(this,Ee,!1);d(this,Se,"syncing");d(this,z,!1);this.stream=e,this.stream.subscribe(p(this,y,fs).bind(this),p(this,y,ms).bind(this))}get isUpToDate(){return n(this,Se)==="up-to-date"}get lastOffset(){return this.stream.lastOffset}get handle(){return this.stream.shapeHandle}get rows(){return this.value.then(e=>Array.from(e.values()))}get currentRows(){return Array.from(this.currentValue.values())}get value(){return new Promise((e,t)=>{if(this.stream.isUpToDate)e(this.currentValue);else{let s=this.subscribe(({value:a})=>{s(),n(this,z)&&t(n(this,z)),e(a)})}})}get currentValue(){return n(this,T)}get error(){return n(this,z)}lastSyncedAt(){return this.stream.lastSyncedAt()}lastSynced(){return this.stream.lastSynced()}isLoading(){return this.stream.isLoading()}isConnected(){return this.stream.isConnected()}get mode(){return this.stream.mode}async requestSnapshot(e){let t=JSON.stringify(e);n(this,De).add(t),await p(this,y,kt).call(this),await this.stream.requestSnapshot(e)}subscribe(e){let t=Math.random();return n(this,$).set(t,e),()=>{n(this,$).delete(t)}}unsubscribeAll(){n(this,$).clear()}get numSubscribers(){return n(this,$).size}};T=new WeakMap,$=new WeakMap,G=new WeakMap,De=new WeakMap,Ee=new WeakMap,Se=new WeakMap,z=new WeakMap,y=new WeakSet,fs=function(e){let t=!1;e.forEach(s=>{if(ae(s))if(t=p(this,y,nt).call(this,"syncing"),this.mode==="full")switch(s.headers.operation){case"insert":n(this,T).set(s.key,s.value);break;case"update":n(this,T).set(s.key,S(S({},n(this,T).get(s.key)),s.value));break;case"delete":n(this,T).delete(s.key);break}else switch(s.headers.operation){case"insert":n(this,G).add(s.key),n(this,T).set(s.key,s.value);break;case"update":n(this,G).has(s.key)&&n(this,T).set(s.key,S(S({},n(this,T).get(s.key)),s.value));break;case"delete":n(this,G).has(s.key)&&(n(this,T).delete(s.key),n(this,G).delete(s.key));break}if(Qe(s))switch(s.headers.control){case"up-to-date":t=p(this,y,nt).call(this,"up-to-date"),n(this,Ee)&&(c(this,Ee,!1),p(this,y,ps).call(this));break;case"must-refetch":n(this,T).clear(),n(this,G).clear(),c(this,z,!1),t=p(this,y,nt).call(this,"syncing"),c(this,Ee,!0);break}}),t&&p(this,y,Ut).call(this)},ps=async function(){await p(this,y,kt).call(this),await Promise.all(Array.from(n(this,De)).map(async e=>{try{let t=JSON.parse(e);await this.stream.requestSnapshot(t)}catch(t){}}))},kt=async function(){this.stream.isUpToDate||await new Promise(e=>{let t=()=>{this.stream.isUpToDate&&(clearInterval(s),a(),e())},s=setInterval(t,10),a=this.stream.subscribe(()=>t(),()=>t());t()})},nt=function(e){let t=n(this,Se)!==e;return c(this,Se,e),t&&e==="up-to-date"},ms=function(e){e instanceof x&&(c(this,z,e),p(this,y,Ut).call(this))},Ut=function(){n(this,$).forEach(e=>{e({value:this.currentValue,rows:this.currentRows})})};export{Je as BackoffDefaults,gt as ELECTRIC_PROTOCOL_QUERY_PARAMS,x as FetchError,ds as Shape,At as ShapeStream,jt as camelToSnake,Vt as createColumnMapper,ae as isChangeMessage,Qe as isControlMessage,ht as isVisibleInSnapshot,Ct as resolveValue,_s as snakeCamelMapper,ot as snakeToCamel};
//# sourceMappingURL=index.browser.mjs.map