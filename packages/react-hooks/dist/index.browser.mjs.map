{"version":3,"sources":["../src/react-hooks.tsx"],"sourcesContent":["import {\n  Shape,\n  ShapeStream,\n  ShapeStreamOptions,\n  Row,\n  GetExtensions,\n} from '@electric-sql/client'\nimport React from 'react'\nimport { useSyncExternalStoreWithSelector } from 'use-sync-external-store/with-selector.js'\n\ntype UnknownShape = Shape<Row<unknown>>\ntype UnknownShapeStream = ShapeStream<Row<unknown>>\n\nconst streamCache = new Map<string, UnknownShapeStream>()\nconst shapeCache = new Map<UnknownShapeStream, UnknownShape>()\n\nexport async function preloadShape<T extends Row<unknown> = Row>(\n  options: ShapeStreamOptions<GetExtensions<T>>\n): Promise<Shape<T>> {\n  const shapeStream = getShapeStream<T>(options)\n  const shape = getShape<T>(shapeStream)\n  await shape.rows\n  return shape\n}\n\nfunction sortObjectKeys(obj: any): any {\n  if (typeof obj === `function`) return Function.prototype.toString.call(obj)\n  if (typeof obj !== `object` || obj === null) return obj\n\n  if (Array.isArray(obj)) {\n    return obj.map(sortObjectKeys)\n  }\n\n  return Object.keys(obj)\n    .sort()\n\n    .reduce<Record<string, any>>((sorted, key) => {\n      sorted[key] = sortObjectKeys(obj[key])\n      return sorted\n    }, {})\n}\n\nexport function sortedOptionsHash<T>(options: ShapeStreamOptions<T>): string {\n  return JSON.stringify(sortObjectKeys(options))\n}\n\nexport function getShapeStream<T extends Row<unknown>>(\n  options: ShapeStreamOptions<GetExtensions<T>>\n): ShapeStream<T> {\n  const shapeHash = sortedOptionsHash(options)\n\n  // If the stream is already cached, return it if valid\n  if (streamCache.has(shapeHash)) {\n    const stream = streamCache.get(shapeHash)! as ShapeStream<T>\n    if (!stream.options.signal?.aborted) {\n      return stream\n    }\n\n    // if stream is aborted, remove it and related shapes\n    streamCache.delete(shapeHash)\n    shapeCache.delete(stream)\n  }\n\n  const newShapeStream = new ShapeStream<T>(options)\n  streamCache.set(shapeHash, newShapeStream)\n\n  // Return the created shape\n  return newShapeStream\n}\n\nexport function getShape<T extends Row<unknown>>(\n  shapeStream: ShapeStream<T>\n): Shape<T> {\n  // If the stream is already cached, return it if valid\n  if (shapeCache.has(shapeStream)) {\n    if (!shapeStream.options.signal?.aborted) {\n      return shapeCache.get(shapeStream)! as Shape<T>\n    }\n\n    // if stream is aborted, remove it and related shapes\n    streamCache.delete(sortedOptionsHash(shapeStream.options))\n    shapeCache.delete(shapeStream)\n  }\n\n  const newShape = new Shape<T>(shapeStream)\n  shapeCache.set(shapeStream, newShape)\n\n  // Return the created shape\n  return newShape\n}\n\nexport interface UseShapeResult<T extends Row<unknown> = Row> {\n  /**\n   * The array of rows that make up the Shape.\n   * @type {T[]}\n   */\n  data: T[]\n  /**\n   * The Shape instance used by this useShape\n   * @type {Shape<T>}\n   */\n  shape: Shape<T>\n  /**\n   * The ShapeStream instance used by this Shape\n   * @type {ShapeStream<T>}\n   */\n  stream: ShapeStream<T>\n  /** True during initial fetch. False afterwise. */\n  isLoading: boolean\n  /** Unix time at which we last synced. Undefined when `isLoading` is true. */\n  lastSyncedAt?: number\n  error: Shape<T>[`error`]\n  isError: boolean\n}\n\nfunction shapeSubscribe<T extends Row<unknown>>(\n  shape: Shape<T>,\n  callback: () => void\n) {\n  const unsubscribe = shape.subscribe(callback)\n  return () => {\n    unsubscribe()\n  }\n}\n\nfunction parseShapeData<T extends Row<unknown>>(\n  shape: Shape<T>\n): UseShapeResult<T> {\n  return {\n    data: shape.currentRows,\n    isLoading: shape.isLoading(),\n    lastSyncedAt: shape.lastSyncedAt(),\n    isError: shape.error !== false,\n    shape,\n    stream: shape.stream as ShapeStream<T>,\n    error: shape.error,\n  }\n}\n\nfunction shapeResultChanged<T extends Row<unknown>>(\n  oldRes: UseShapeResult<T> | undefined,\n  newRes: UseShapeResult<T>\n): boolean {\n  return (\n    !oldRes ||\n    oldRes.isLoading !== newRes.isLoading ||\n    oldRes.lastSyncedAt !== newRes.lastSyncedAt ||\n    oldRes.isError !== newRes.isError ||\n    oldRes.error !== newRes.error ||\n    oldRes.shape.lastOffset !== newRes.shape.lastOffset ||\n    oldRes.shape.handle !== newRes.shape.handle\n  )\n}\n\nfunction identity<T>(arg: T): T {\n  return arg\n}\n\ninterface UseShapeOptions<SourceData extends Row<unknown>, Selection>\n  extends ShapeStreamOptions<GetExtensions<SourceData>> {\n  selector?: (value: UseShapeResult<SourceData>) => Selection\n}\n\nexport function useShape<\n  SourceData extends Row<unknown> = Row,\n  Selection = UseShapeResult<SourceData>,\n>({\n  selector = identity as (arg: UseShapeResult<SourceData>) => Selection,\n  ...options\n}: UseShapeOptions<SourceData, Selection>): Selection {\n  const shapeStream = getShapeStream<SourceData>(\n    options as ShapeStreamOptions<GetExtensions<SourceData>>\n  )\n  const shape = getShape<SourceData>(shapeStream)\n\n  const useShapeData = React.useMemo(() => {\n    let latestShapeData: UseShapeResult<SourceData> | undefined\n\n    const getSnapshot = () => {\n      latestShapeData ??= parseShapeData(shape)\n      return latestShapeData\n    }\n\n    const subscribe = (onStoreChange: () => void) => {\n      // check if shape has changed between the initial snapshot\n      // and subscribing, as there are no guarantees that the\n      // two will occur synchronously with each other\n      const newShapeData = parseShapeData(shape)\n      if (shapeResultChanged(latestShapeData, newShapeData)) {\n        latestShapeData = newShapeData\n        onStoreChange()\n      }\n\n      return shapeSubscribe(shape, () => {\n        latestShapeData = parseShapeData(shape)\n        onStoreChange()\n      })\n    }\n\n    return () => {\n      return useSyncExternalStoreWithSelector(\n        subscribe,\n        getSnapshot,\n        getSnapshot,\n        selector\n      )\n    }\n  }, [shape, selector])\n\n  return useShapeData()\n}\n"],"mappings":"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","names":["Shape","ShapeStream","React","useSyncExternalStoreWithSelector","streamCache","shapeCache","preloadShape","options","shapeStream","getShapeStream","shape","getShape","sortObjectKeys","obj","sorted","key","sortedOptionsHash","_a","shapeHash","stream","newShapeStream","ShapeStream","newShape","Shape","shapeSubscribe","callback","unsubscribe","parseShapeData","shapeResultChanged","oldRes","newRes","identity","arg","useShape","_b","selector","__objRest","React","latestShapeData","getSnapshot","subscribe","onStoreChange","newShapeData","useSyncExternalStoreWithSelector"]}